#!/usr/bin/env bash

# Generic parallel CI test runner
# Supports both acceptance tests and migration tests
# Dynamically detects which services have sweeper implementations by grepping for AddTestSweepers

# ./internal/services/account
# account creation can only be done by a tenant admin and the current CI does 
# have that support.
# TODO: support tenant admin auth for acceptance tests

# List of service paths to test
SERVICES=(
    "./internal/services/account"
    "./internal/services/account_api_token_permission_groups"
    "./internal/services/account_dns_settings"
    "./internal/services/account_dns_settings_internal_view"
    "./internal/services/account_member"
    "./internal/services/account_permission_group"
    "./internal/services/account_role"
    "./internal/services/account_subscription"
    "./internal/services/account_token"
    "./internal/services/address_map"
    "./internal/services/api_shield"
    "./internal/services/api_token"
    "./internal/services/argo_smart_routing"
    "./internal/services/argo_tiered_caching"
    "./internal/services/authenticated_origin_pulls"
    "./internal/services/authenticated_origin_pulls_certificate"
    "./internal/services/byo_ip_prefix"
    "./internal/services/certificate_pack"
    "./internal/services/cloud_connector_rules"
    "./internal/services/custom_pages"
    "./internal/services/custom_ssl"
    "./internal/services/dns_record"
    "./internal/services/dns_settings_internal_view"
    "./internal/services/dns_zone_transfers_acl"
    "./internal/services/dns_zone_transfers_tsig"
    "./internal/services/email_routing_catch_all"
    "./internal/services/email_routing_dns"
    "./internal/services/email_routing_rule"
    "./internal/services/email_security_impersonation_registry"
    "./internal/services/email_security_trusted_domains"
    "./internal/services/ip_ranges"
    "./internal/services/list"
    "./internal/services/list_item"
    "./internal/services/load_balancer"
    "./internal/services/load_balancer_monitor"
    "./internal/services/load_balancer_pool"
    "./internal/services/logpull_retention"
    "./internal/services/logpush_job"
    "./internal/services/logpush_ownership_challenge"
    "./internal/services/magic_transit_connector"
    "./internal/services/magic_wan_ipsec_tunnel"
    "./internal/services/magic_wan_gre_tunnel"
    "./internal/services/magic_wan_static_route"
    "./internal/services/managed_transforms"
    "./internal/services/observatory_scheduled_test"
    "./internal/services/origin_ca_certificate"
    "./internal/services/page_rule"
    "./internal/services/pages_domain"
    "./internal/services/pages_project"
    "./internal/services/queue"
    "./internal/services/r2_bucket"
    "./internal/services/regional_tiered_cache"
    "./internal/services/ruleset"
    "./internal/services/spectrum_application"
    "./internal/services/tiered_cache"
    "./internal/services/turnstile_widget"
    "./internal/services/url_normalization_settings"
    "./internal/services/waiting_room_settings"
    "./internal/services/workers_cron_trigger"
    "./internal/services/workers_custom_domain"
    "./internal/services/workers_for_platforms_dispatch_namespace"
    "./internal/services/workers_kv_namespace"
    "./internal/services/workers_route"
    "./internal/services/workers_script"
    "./internal/services/zero_trust_access_application"
    "./internal/services/zero_trust_access_custom_page"
    "./internal/services/zero_trust_access_group"
    "./internal/services/zero_trust_access_identity_provider"
    "./internal/services/zero_trust_access_key_configuration"
    "./internal/services/zero_trust_access_mtls_certificate"
    "./internal/services/zero_trust_access_mtls_hostname_settings"
    "./internal/services/zero_trust_access_policy"
    "./internal/services/zero_trust_access_service_token"
    "./internal/services/zero_trust_access_short_lived_certificate"
    "./internal/services/zero_trust_access_tag"
    "./internal/services/zero_trust_device_custom_profile"
    "./internal/services/zero_trust_device_custom_profile_local_domain_fallback"
    "./internal/services/zero_trust_device_default_profile_certificates"
    "./internal/services/zero_trust_device_managed_networks"
    "./internal/services/zero_trust_gateway_proxy_endpoint"
    "./internal/services/zero_trust_gateway_settings"
    "./internal/services/zero_trust_list"
    "./internal/services/zero_trust_organization"
    "./internal/services/zero_trust_tunnel_cloudflared"
    "./internal/services/zero_trust_tunnel_cloudflared_route"
    "./internal/services/zero_trust_tunnel_cloudflared_token"
    "./internal/services/zone"
    "./internal/services/zone_cache_reserve"
    "./internal/services/zone_cache_variants"
    "./internal/services/zone_hold"
    "./internal/services/zone_lockdown"
    "./internal/services/zone_setting"
    "./internal/services/zone_subscription"
)

set -e

# Configuration
PARALLEL_JOBS=${PARALLEL_JOBS:-3}  # Number of parallel jobs (can be overridden)
LOG_DIR="./test-logs"
SWEEP_TIMEOUT="5m"
TEST_TIMEOUT="15m"
TEST_TYPE="acceptance"  # Default test type

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Create log directory
mkdir -p "$LOG_DIR"

# Function to log with timestamp
log() {
    echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Function to check if a service has a sweeper by grepping for AddTestSweepers
has_sweeper() {
    local service="$1"
    
    # Look for AddTestSweepers in resource_test.go files
    # We need to check both resource_test.go and any other *_test.go files
    local test_files=("$service"/*_test.go)
    
    for test_file in "${test_files[@]}"; do
        if [ -f "$test_file" ]; then
            # Look for uncommented AddTestSweepers calls
            if grep -q "^[[:space:]]*resource\.AddTestSweepers" "$test_file" 2>/dev/null; then
                return 0
            fi
        fi
    done
    
    return 1
}

# Function to check if a service has migration tests
has_migration_tests() {
    local service="$1"
    
    # Look for TestMigrate functions in test files
    local test_files=("$service"/*_test.go)
    
    for test_file in "${test_files[@]}"; do
        if [ -f "$test_file" ]; then
            # Look for TestMigrate function definitions
            if grep -q "^func TestMigrate" "$test_file" 2>/dev/null; then
                return 0
            fi
        fi
    done
    
    return 1
}

# Function to run sweeper for a service
run_sweeper() {
    local service="$1"
    local log_file="$LOG_DIR/$(basename "$service")-sweeper.log"
    local start_time=$(date +%s)
    
    # Check if this service has a sweeper implementation
    if ! has_sweeper "$service"; then
        log "${YELLOW}Skipping sweeper for $service (no sweeper implemented)${NC}" > "$log_file"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Skipping sweeper for $service (no sweeper implemented)"
        return 0
    fi
    
    log "${WHITE}Sweeping: $service${NC}" > "$log_file"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Sweeping: $service"
    
    # Use the correct sweeper syntax with -sweep-run parameter
    local service_name=$(basename "$service")
    local sweeper_name="cloudflare_${service_name}"
    
    if TF_ACC=1 go test -v "$service" -sweep=all -sweep-run="$sweeper_name" -timeout "$SWEEP_TIMEOUT" >> "$log_file" 2>&1; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${GREEN}✓ Sweeper completed: $service (${duration}s total)${NC}" >> "$log_file"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] ✓ Sweeper completed: $service (${duration}s total)"
        return 0
    else
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${RED}✗ Sweeper failed: $service (${duration}s total) - check $log_file${NC}" >> "$log_file"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] ✗ Sweeper failed: $service (${duration}s total) - check $log_file"
        return 1
    fi
}

# Function to run tests for a service
run_tests() {
    local service="$1"
    local log_file="$LOG_DIR/$(basename "$service")-tests.log"
    local start_time=$(date +%s)
    local test_pattern test_name
    
    # Set test pattern and name based on test type
    if [ "$TEST_TYPE" = "migration" ]; then
        test_pattern="^TestMigrate"
        test_name="migration tests"
        
        # Check if this service has migration tests
        if ! has_migration_tests "$service"; then
            log "${YELLOW}Skipping $test_name for $service (no migration tests found)${NC}" > "$log_file"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Skipping $test_name for $service (no migration tests found)"
            return 0
        fi
    else
        test_pattern="^TestAcc"
        test_name="acceptance tests"
    fi
    
    log "${WHITE}Running $test_name: $service${NC}" > "$log_file"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Running $test_name: $service"
    
    if TF_ACC=1 go test -run "$test_pattern" -count 1 -timeout "$TEST_TIMEOUT" "$service" >> "$log_file" 2>&1; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${GREEN}✓ Tests completed successfully for $service (${duration}s)${NC}" >> "$log_file"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] ✓ Tests completed successfully for $service (${duration}s)"
        return 0
    else
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${RED}✗ Tests failed for $service (${duration}s) - check $log_file${NC}" >> "$log_file"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] ✗ Tests failed for $service (${duration}s) - check $log_file"
        return 1
    fi
}

# Function to process a single service (sweeper + tests)
process_service() {
    local service="$1"
    local service_name=$(basename "$service")
    local combined_log="$LOG_DIR/${service_name}-combined.log"
    local start_time=$(date +%s)
    
    {
        log "${WHITE}Processing service: $service${NC}"
        
        # Only run sweepers for acceptance tests, not migration tests
        if [ "$TEST_TYPE" != "migration" ]; then
            if ! run_sweeper "$service"; then
                log "${YELLOW}Sweeper issues for $service, continuing with tests...${NC}"
            fi
        else
            log "${YELLOW}Skipping sweeper for migration tests: $service${NC}"
        fi
        
        # Run tests
        run_tests "$service"
        local test_result=$?
        
        local end_time=$(date +%s)
        local total_duration=$((end_time - start_time))
        
        if [ $test_result -eq 0 ]; then
            log "${GREEN}✓ Completed: $service (${total_duration}s total)${NC}"
        else
            log "${RED}✗ Failed: $service (${total_duration}s total)${NC}"
        fi
        
        return $test_result
    } > "$combined_log" 2>&1
    
    # Always show the result summary
    tail -1 "$combined_log"
    return $?
}

# Export function so it can be used by xargs
export -f process_service run_sweeper run_tests log has_sweeper has_migration_tests
export LOG_DIR SWEEP_TIMEOUT TEST_TIMEOUT TEST_TYPE RED GREEN YELLOW WHITE NC

# Main execution
main() {
    local start_time=$(date +%s)
    local test_name_display
    
    if [ "$TEST_TYPE" = "migration" ]; then
        test_name_display="migration tests"
    else
        test_name_display="acceptance tests"
    fi
    
    log "${GREEN}Starting parallel CI $test_name_display with $PARALLEL_JOBS jobs${NC}"
    log "${WHITE}Total services to test: ${#SERVICES[@]}${NC}"
    log "${WHITE}Logs will be written to: $LOG_DIR${NC}"
    log "${WHITE}Sweeper timeout: $SWEEP_TIMEOUT, Test timeout: $TEST_TIMEOUT${NC}"
    echo ""
    
    # Clean up old logs
    rm -f "$LOG_DIR"/*.log
    
    log "${WHITE}Running tests with xargs. Real-time output will be shown below:${NC}"
    echo ""
    
    # Start a background job to show progress counts
    (
        while sleep 30; do
            completed=$(find "$LOG_DIR" -name "*-combined.log" -exec grep -l "✓ Completed:\|✗ Failed:" {} \; 2>/dev/null | wc -l | tr -d ' ')
            total=${#SERVICES[@]}
            log "${WHITE}Progress: $completed/$total services completed${NC}"
        done
    ) &
    progress_pid=$!
    
    # Start a background job to tail log output and show all detailed progress
    (
        sleep 3  # Give tests a moment to start creating log files
        monitored_list=""
        while true; do
            # Monitor only sweeper and tests log files to get detailed output
            for log_file in "$LOG_DIR"/*-sweeper.log "$LOG_DIR"/*-tests.log; do
                [ -f "$log_file" ] || continue
                # Check if we've already started monitoring this file
                if ! echo "$monitored_list" | grep -q "$log_file"; then
                    monitored_list="$monitored_list $log_file"
                    # Show all content from sweeper and test log files
                    (
                        tail -f "$log_file" 2>/dev/null || true
                    ) &
                fi
            done
            sleep 3
        done
    ) &
    tail_monitor_pid=$!
    
    printf '%s\n' "${SERVICES[@]}" | xargs -I {} -P "$PARALLEL_JOBS" bash -c 'process_service "$@"' _ {}
    parallel_result=$?
    
    # Calculate timing and count results first (outside the atomic block)
    local end_time=$(date +%s)
    local total_duration=$((end_time - start_time))
    local minutes=$((total_duration / 60))
    local seconds=$((total_duration % 60))
    
    # Count results
    local passed=0
    local failed=0
    local failed_list=""
    
    # Temporarily disable exit on error during counting
    set +e
    
    for service in "${SERVICES[@]}"; do
        local service_name=$(basename "$service")
        local combined_log="$LOG_DIR/${service_name}-combined.log"
        
        if [ -f "$combined_log" ] && grep -q "✓ Completed:" "$combined_log" 2>/dev/null; then
            ((passed++))
        else
            ((failed++))
            failed_list="$failed_list$service "
        fi
    done
    
    # Re-enable exit on error
    set -e
    
    # Stop background processes first to prevent "Terminated" messages
    log "${WHITE}Stopping background monitoring...${NC}"
    kill $progress_pid 2>/dev/null || true
    kill $tail_monitor_pid 2>/dev/null || true
    # Give processes time to exit cleanly
    sleep 2
    # Kill any remaining child processes silently
    pkill -P $tail_monitor_pid >/dev/null 2>&1 || true
    
    # Create summary output atomically to minimize interruption window
    {
        echo ""
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] === EXECUTION SUMMARY ==="
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Total execution time: ${minutes}m ${seconds}s"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Passed: $passed"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Failed: $failed"
        
        if [ $failed -gt 0 ]; then
            echo ""
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Failed services:"
            for service in $failed_list; do
                echo "[$(date '+%Y-%m-%d %H:%M:%S')]   - $service"
            done
            echo ""
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Check individual log files in $LOG_DIR for detailed error information"
        fi
        
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Summary complete"
    } | cat  # Using cat to force immediate output as a single block
    
    # Final status message - only fail if actual tests failed, not xargs issues
    if [ $failed -gt 0 ]; then
        log "${RED}Some tests failed - see details above${NC}"
        exit 1
    fi
    
    log "${GREEN}All tests completed successfully!${NC}"
}

# Simple cleanup function for any remaining background processes
cleanup() {
    # Quietly clean up any remaining background processes
    jobs -p | xargs -r kill -TERM >/dev/null 2>&1 || true
    pkill -f "tail -f.*$LOG_DIR" >/dev/null 2>&1 || true
    # Give processes a moment to exit
    sleep 1
}

trap cleanup EXIT

# Usage information
if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    echo "Usage: $0 [test-type] [options]"
    echo ""
    echo "Arguments:"
    echo "  test-type          Type of tests to run: 'acceptance' or 'migration' (default: acceptance)"
    echo ""
    echo "Options:"
    echo "  --help, -h         Show this help message"
    echo "  --jobs N           Number of parallel jobs (default: $PARALLEL_JOBS)"
    echo "  --sweep-timeout T  Timeout for sweeper operations (default: $SWEEP_TIMEOUT)"
    echo "  --test-timeout T   Timeout for test operations (default: $TEST_TIMEOUT)"
    echo ""
    echo "Environment variables:"
    echo "  PARALLEL_JOBS      Override default parallel job count"
    echo ""
    echo "Examples:"
    echo "  $0                                    # Run acceptance tests with default settings"
    echo "  $0 migration                         # Run migration tests"
    echo "  $0 acceptance --jobs 4               # Run acceptance tests with 4 parallel jobs"
    echo "  $0 migration --test-timeout 20m      # Run migration tests with 20 minute timeout"
    echo "  PARALLEL_JOBS=8 $0 acceptance        # Run with 8 parallel jobs"
    exit 0
fi

# Parse test type first
if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
    case $1 in
        acceptance|migration)
            TEST_TYPE="$1"
            shift
            ;;
        --dry-run)
            # Keep handling --dry-run as before, but will handle below
            ;;
        *)
            echo "Unknown test type: $1"
            echo "Valid test types: acceptance, migration"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
fi

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            echo "Would run ${#SERVICES[@]} services with $PARALLEL_JOBS parallel jobs ($TEST_TYPE tests)"
            printf '%s\n' "${SERVICES[@]}"
            exit 0
            ;;
        --jobs)
            PARALLEL_JOBS="$2"
            shift 2
            ;;
        --sweep-timeout)
            SWEEP_TIMEOUT="$2"
            shift 2
            ;;
        --test-timeout)
            TEST_TIMEOUT="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Validate PARALLEL_JOBS is a number
if ! [[ "$PARALLEL_JOBS" =~ ^[0-9]+$ ]] || [ "$PARALLEL_JOBS" -lt 1 ]; then
    log "${RED}Error: PARALLEL_JOBS must be a positive integer${NC}"
    exit 1
fi

# Run main function
main
